
/* Do not modify this file it was automatically generated by the
 * TokenList2DsnLexer CMake script.
 *
 * Include this file in your lexer class to provide the keywords for
 * your DSN lexer.
 */

#include </home/vboxuser/Desktop/openSi/kicad-build/common/drc_rules_lexer.h>

using namespace DRCRULE_T;

#define TOKDEF(x)    { #x, T_##x }

const KEYWORD DRC_RULES_LEXER::keywords[] = {
    TOKDEF( annular_width ),
    TOKDEF( assertion ),
    TOKDEF( board_edge ),
    TOKDEF( buried_via ),
    TOKDEF( clearance ),
    TOKDEF( condition ),
    TOKDEF( connection_width ),
    TOKDEF( constraint ),
    TOKDEF( courtyard_clearance ),
    TOKDEF( diff_pair_gap ),
    TOKDEF( diff_pair_uncoupled ),
    TOKDEF( disallow ),
    TOKDEF( edge_clearance ),
    TOKDEF( error ),
    TOKDEF( exclusion ),
    TOKDEF( footprint ),
    TOKDEF( graphic ),
    TOKDEF( hole ),
    TOKDEF( hole_clearance ),
    TOKDEF( hole_size ),
    TOKDEF( hole_to_hole ),
    TOKDEF( ignore ),
    TOKDEF( inner ),
    TOKDEF( layer ),
    TOKDEF( length ),
    TOKDEF( max ),
    TOKDEF( mechanical_clearance ),
    TOKDEF( mechanical_hole_clearance ),
    TOKDEF( micro_via ),
    TOKDEF( min ),
    TOKDEF( min_resolved_spokes ),
    TOKDEF( none ),
    TOKDEF( npth ),
    TOKDEF( opt ),
    TOKDEF( outer ),
    TOKDEF( pad ),
    TOKDEF( physical_clearance ),
    TOKDEF( physical_hole_clearance ),
    TOKDEF( pth ),
    TOKDEF( rule ),
    TOKDEF( severity ),
    TOKDEF( silk_clearance ),
    TOKDEF( skew ),
    TOKDEF( solid ),
    TOKDEF( text ),
    TOKDEF( text_height ),
    TOKDEF( text_thickness ),
    TOKDEF( thermal_relief_gap ),
    TOKDEF( thermal_reliefs ),
    TOKDEF( thermal_spoke_width ),
    TOKDEF( track ),
    TOKDEF( track_width ),
    TOKDEF( version ),
    TOKDEF( via ),
    TOKDEF( via_count ),
    TOKDEF( via_diameter ),
    TOKDEF( warning ),
    TOKDEF( zone ),
    TOKDEF( zone_connection )
};

const unsigned DRC_RULES_LEXER::keyword_count = unsigned( sizeof( DRC_RULES_LEXER::keywords )/sizeof( DRC_RULES_LEXER::keywords[0] ) );


const char* DRC_RULES_LEXER::TokenName( T aTok )
{
    const char* ret;

    if( aTok < 0 )
        ret = DSNLEXER::Syntax( aTok );
    else if( (unsigned) aTok < keyword_count )
        ret = keywords[aTok].name;
    else
        ret = "token too big";

    return ret;
}


const KEYWORD_MAP DRC_RULES_LEXER::keywords_hash({
    { "annular_width", 0 },
    { "assertion", 1 },
    { "board_edge", 2 },
    { "buried_via", 3 },
    { "clearance", 4 },
    { "condition", 5 },
    { "connection_width", 6 },
    { "constraint", 7 },
    { "courtyard_clearance", 8 },
    { "diff_pair_gap", 9 },
    { "diff_pair_uncoupled", 10 },
    { "disallow", 11 },
    { "edge_clearance", 12 },
    { "error", 13 },
    { "exclusion", 14 },
    { "footprint", 15 },
    { "graphic", 16 },
    { "hole", 17 },
    { "hole_clearance", 18 },
    { "hole_size", 19 },
    { "hole_to_hole", 20 },
    { "ignore", 21 },
    { "inner", 22 },
    { "layer", 23 },
    { "length", 24 },
    { "max", 25 },
    { "mechanical_clearance", 26 },
    { "mechanical_hole_clearance", 27 },
    { "micro_via", 28 },
    { "min", 29 },
    { "min_resolved_spokes", 30 },
    { "none", 31 },
    { "npth", 32 },
    { "opt", 33 },
    { "outer", 34 },
    { "pad", 35 },
    { "physical_clearance", 36 },
    { "physical_hole_clearance", 37 },
    { "pth", 38 },
    { "rule", 39 },
    { "severity", 40 },
    { "silk_clearance", 41 },
    { "skew", 42 },
    { "solid", 43 },
    { "text", 44 },
    { "text_height", 45 },
    { "text_thickness", 46 },
    { "thermal_relief_gap", 47 },
    { "thermal_reliefs", 48 },
    { "thermal_spoke_width", 49 },
    { "track", 50 },
    { "track_width", 51 },
    { "version", 52 },
    { "via", 53 },
    { "via_count", 54 },
    { "via_diameter", 55 },
    { "warning", 56 },
    { "zone", 57 },
    { "zone_connection", 58 }
});